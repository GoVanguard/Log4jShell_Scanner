#!/usr/bin/env python3
'''GoVanguard Log4J Shell Scanner Script'''
# WARNING: If you contact me over my variable naming you'll be blacklisted. PEP8 has no style and zero funk #

from urllib.parse import urlparse
import time
import sys
import argparse
import json
import requests
from bs4 import BeautifulSoup
from pyfiglet import Figlet

## Disable bullshit
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
##

def sumDict(inputDictA: dict, inputDictB: dict) -> dict:
    '''Combine two dictionaries. Clobber A -> B'''
    for item in inputDictA:
        inputDictB[item] = inputDictA[item]
    return inputDictB

class Logger():
    '''Logger class for screen and logfile'''
    def __init__(self, sourceFile, term, log):
        self.prefix = sourceFile.split("/")[-1:][0].split(".")[0]
        self.terminal = term
        self.filename = "./logs/{0}-{1}.log".format(str(self.prefix), str(log))
        self.log = open(self.filename, "w", encoding="utf8")
        self.terminal = term

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)

    def flush(self):
        pass


def setupLogger(sourceFile: str) -> None:
    '''Basic logging setup'''
    sys.stdout = Logger(sourceFile, sys.stdout, "stdout")
    sys.stderr = Logger(sourceFile, sys.stderr, "stderr")


def welcome() -> None:
    '''Welcome splash'''
    figgerOb = Figlet()
    print(figgerOb.renderText('GoVanguard Log4J Shell Scanner'))
    print("\n")
    print("Tests headers, form elements and query parameters for the Log4J Shell vulnerability.\n")


def setupParser():
    '''Setup and process argv parser'''
    if len(sys.argv) <= 1:
        print('\n%s -h for help.' % (sys.argv[0]))
        sys.exit(1)

    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--file",
                    dest="sourceFile",
                    help="Source file containing endpoints to check without scheme. One host per line.",
                    action='store')
    parser.add_argument("-t", "--timeout",
                    dest="timeout",
                    help="Request timeout period.",
                    default="3",
                    action='store')
    parser.add_argument("-k", "--ignoressl",
                    dest="verifySsl",
                    help = "Whether or not to ignore invalid certificates.",
                    default = True,
                    action='store_false')
    parser.add_argument("-s", "--schemes",
                    dest="schemes",
                    help = "Schemes to prefix such as http or https.",
                    default = ["http", "https"],
                    nargs='+',
                    action='append')
    parser.add_argument("-p", "--payload",
                    dest="testPayload",
                    help = "Test payload from https://log4shell.huntress.com/. Escape any $ or payload will seem blank.",
                    required=True,
                    action='store')
    parser.add_argument("-q", "--fuzzqueryparams",
                    dest="fuzzQueryParams",
                    help = "Enable fuzzing query parameters.",
                    default = False,
                    action='store_true')
    parser.add_argument("-i", "--fuzzinputs",
                    dest="fuzzFormInputs",
                    help = "Enable fuzzing form inputs.",
                    default = False,
                    action='store_true')
    parser.add_argument("-z", "--fuzzheaders",
                    dest="fuzzHeaders",
                    help = "Enable fuzzing headers.",
                    default = False,
                    action='store_true')
    parser.add_argument("-b", "--fuzzbodyparams",
                    dest="fuzzBodyParams",
                    help = "Enable fuzzing body parameters.",
                    default = False,
                    action='store_true')
    parser.add_argument("-v", "--headers",
                    dest="extraHeaders",
                    help = "Extra headers to pass in \"{'name':'value'}\" format.",
                    action='store')

    args = parser.parse_args()
    return args


def makeCalls(callsToMake: list, timeout: int, verifySsl: bool) -> None:
    '''Executes each callToMake as described'''
    print("Entering execution phase...")
    print("---------------------------")
    print("Test payload: {0}".format(str(testPayload)))
    print("Fuzz Headers: {0}".format(str(args.fuzzHeaders)))
    print("Fuzz Form Inputs: {0}".format(str(args.fuzzFormInputs)))
    print("Fuzz QueryParams: {0}".format(str(args.fuzzQueryParams)))
    print("Fuzz BodyParams: {0}".format(str(args.fuzzBodyParams)))
    print("Extra headers: {0}".format(str(json.dumps(args.extraHeaders))))
    print("Operation Timeout: {0}".format(str(timeout)))
    print("Verify SSL: {0}\n".format(str(verifySsl)))
    print("Executing {0} attacks...".format(str(len(callsToMake))))
    print("--------------------")

    for callToMake in callsToMake:
        try:
            print("Executing {0} to {1}...".format(callToMake['method'], callToMake['url']))
            print("    > Headers: {0}".format(callToMake['headers']))
            if callToMake['method'] == 'post' and callToMake['bodyParams'] == {}:
                requestOb = requests.post(callToMake['url'], headers = callToMake['headers'], timeout = timeout, verify = verifySsl)
            elif callToMake['method'] == 'post' and len(callToMake['bodyParams']) > 0 and args.fuzzBodyParams:
                print("    > Body params: {0}".format(str(callToMake['bodyParams'])))
                bodyJson = json.dumps(callToMake['bodyParams'])
                requestOb = requests.post(callToMake['url'], headers = callToMake['headers'], json = bodyJson, timeout = timeout, verify = verifySsl)
            else:
                requestOb = requests.get(callToMake['url'], headers = callToMake['headers'], timeout = timeout, verify = verifySsl)
            requestOb.raise_for_status()
            print("    > Code: {0}\n".format(str(requestOb.status_code)))
        except requests.exceptions.HTTPError as errh:
            print("    > HTTP error: {0}\n".format(str(errh)))
        except requests.exceptions.ConnectionError as errc:
            print("    > Wouldn't connect: {0}\n".format(str(errc)))
        except requests.exceptions.Timeout as errt:
            print("    > Timed out: {0}\n".format(str(errt)))
        except requests.exceptions.RequestException as err:
            print("    > Didn't respond as expected: {0}\n".format(str(err)))
        except Exception as err:
            print("    > Something else failed: {0}\n".format(str(err)))
        time.sleep(2)


def buildHosts(sourceFile: list, schemes = ['https', 'http']) -> list:
    '''Builds a list of endpoints from a source file to supply to thr analysis sphase'''
    print("Entering host collection phase...")
    print("---------------------------------")
    if not sourceFile:
        print("    > No endpoint source file supplied")
        sys.exit(1)
    try:
        print("    > Source File: {0}".format(str(sourceFile)))
        print("    > Schemes: {0}".format(str(schemes)))
        fileObj = open(sourceFile, "r", encoding="utf8")
        fileData = fileObj.read().strip().split("\n")
    except Exception as err:
        print("    > Couldn't read source file {0}: {1}".format(str(sourceFile), str(err)))
        sys.exit(1)

    hostsToTest = []
    for scheme in schemes:
        hostsToTest += ["{0}://{1}".format(str(scheme), str(line)) for line in fileData]
    print("    > {0} endpoints\n".format(str(len(hostsToTest))))
    return hostsToTest


def analyzeHosts(hostsToTest: list, timeout: int, verifySsl: bool) -> list:
    '''Probe each endpoint and create a list of calls with strategic attacks based on options'''
    print("Entering analysis phase...")
    print("--------------------------")
    print("Fuzz Headers: {0}".format(str(args.fuzzHeaders)))
    print("Fuzz Form Inputs: {0}".format(str(args.fuzzFormInputs)))
    print("Fuzz QueryParams: {0}".format(str(args.fuzzQueryParams)))
    print("Fuzz BodyParams: {0}".format(str(args.fuzzBodyParams)))
    print("Extra headers: {0}".format(str(json.dumps(args.extraHeaders))))
    print("Operation Timeout: {0}".format(str(timeout)))
    print("Verify SSL: {0}\n".format(str(verifySsl)))
    print("Executing analysis on {0} endpoints...".format(str(len(hostsToTest))))
    print("--------------------------------------")

    callsToMake = []
    for hostToTest in hostsToTest:
        endPoint = hostToTest
        urlParserOb=urlparse(endPoint)
        url = endPoint
        # Shitty replace
        url = url.replace(urlParserOb.query, "").replace(urlParserOb.fragment, "").replace("?", "")

        try:
            print("Analyzing {0}...".format(str(url)))
            if args.extraHeaders:
                # Cry me a river. It's a eval. Not a vuiln for a script run adhoc. Deal with it.
                extraHeaders = eval(args.extraHeaders)
                print("    > Extra Headers: {0}".format(str(extraHeaders)))
            requestOb = requests.get(url, timeout = timeout, verify = verifySsl, headers = extraHeaders)
            responseText = requestOb.text
            requestOb.raise_for_status()
            print("    > Code: {0}".format(str(requestOb.status_code)))
        except requests.exceptions.HTTPError as errh:
            print("    > HTTP error: {0}\n".format(str(errh)))
            continue
        except requests.exceptions.ConnectionError as errc:
            print("    > Wouldn't connect: {0}\n".format(str(errc)))
            continue
        except requests.exceptions.Timeout as errt:
            print("    > Timed out: {0}\n".format(str(errt)))
            continue
        except requests.exceptions.RequestException as err:
            print("    > Didn't respond as expected: {0}\n".format(str(err)))
            continue
        except Exception as err:
            print("    > Something else failed: {0}\n".format(str(err)))
            continue

        soup = BeautifulSoup(responseText, features="lxml")

        allParameters = []

        queryParameters = [str(inputPair.split("=")[0]) for inputPair in urlParserOb.query.split("&&") if len(inputPair.split("=")[0]) > 0]
        if len(queryParameters) == 0:
            queryParameters = ["fuzqp"]
        formInputs = [str(inputObj.attrs['name']) for inputObj  in soup.find_all('input') if str(inputObj.attrs['type']) != 'submit']
        bodyParameters = ["fuzzbp"]

        if queryParameters:
            print("    > Found query params: {0}".format(str(queryParameters)))
            allParameters = allParameters + queryParameters

        if formInputs:
            print("    > Found form inputs: {0}".format(str(formInputs)))
            allParameters = allParameters + formInputs

        print("    > Body params: {0}".format(str(bodyParameters)))

        formSearch = soup.find_all('form')
        if len(formSearch) > 0:
            formObj = soup.find_all('form')[0]
            formAttrs = formObj.attrs
            formAction = formAttrs['action']
            formMethod = formAttrs['method']
            print("    > Form action: {0}, Form method: {1}\n".format(str(formAction), str(formMethod).upper()))
        else:
            formMethod = "get"
            print("    > Form method: {0}\n".format(str(formMethod).upper()))

        #headers = requestOb.headers
        #headers = headers.copy()
        headers = {}
        if args.extraHeaders:
            # Cry me a river. It's a eval. Not a vuiln for a script run adhoc. Deal with it
            extraHeaders = eval(args.extraHeaders)
            #headers = sumDict(headers, extraHeaders)
            headers = extraHeaders

        # Some extra headers to try
        fuzzHeaders = {}
        fuzzHeaders['User-Agent'] = 'log4j tester'
        fuzzHeaders['Referrer-Policy'] = 'origin'
        fuzzHeaders['Accept'] = '*/*'
        fuzzHeaders['Logger'] = 'debug'

        newHeaderSets = []
        lenHeaders = len(fuzzHeaders)

        for headerEntry in range(0, lenHeaders):
            newHeaders = fuzzHeaders.copy()
            origHeaders = headers.copy()
            targetHeader = list(newHeaders.keys())[headerEntry]
            newHeaders[targetHeader] = testPayload
            completeSetNewHeaders = sumDict(newHeaders, origHeaders)
            newHeaderSets.append(completeSetNewHeaders)

        if formMethod == "post":
            callStr = "{0}/{1}".format(url, formAction)
        else:
            callStr = url

        if args.fuzzFormInputs:
            for parameter in formInputs:
                callStr = callStr + "?{0}={1}".format(parameter, testPayload)
            if args.fuzzHeaders:
                for newHeaderSet in newHeaderSets:
                    callsToMake.append({'url': callStr, 'headers': newHeaderSet, 'method': formMethod.lower(), 'bodyParams': {}})
            else:
                callsToMake.append({'url': callStr, 'headers': headers, 'method': formMethod.lower(), 'bodyParams': {}})

        if args.fuzzQueryParams:
            for parameter in queryParameters:
                callStr = callStr + "?{0}={1}".format(parameter, testPayload)
            if args.fuzzHeaders:
                for newHeaderSet in newHeaderSets:
                    callsToMake.append({'url': callStr, 'headers': newHeaderSet, 'method': formMethod.lower(), 'bodyParams': {}})
            else:
                callsToMake.append({'url': callStr, 'headers': headers, 'method': formMethod.lower(), 'bodyParams': {}})

        if formMethod == "post" and args.fuzzBodyParams:
            for parameter in bodyParameters:
                callsToMake.append({'url': callStr, 'headers': headers, 'method': formMethod.lower(), 'bodyParams': {parameter: str(testPayload)}})
                callsToMake.append({'url': url, 'headers': headers, 'method': formMethod.lower(), 'bodyParams': {parameter: str(testPayload)}})

    return callsToMake


args = setupParser()
sourceFile = str(args.sourceFile)
timeout = int(args.timeout)
verifySsl = bool(args.verifySsl)
schemes = [scheme[0] for scheme in args.schemes]
testPayload = str(args.testPayload)

setupLogger(sourceFile)
welcome()
hostToTest = buildHosts(sourceFile, schemes)
callsToMake = analyzeHosts(hostToTest, timeout, verifySsl)
makeCalls(callsToMake, timeout, verifySsl)
